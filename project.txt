config3.py
"""
config.py ‚Äî –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—è –ø—Ä–æ–µ–∫—Ç–∞: –ø–µ—Ä–µ–º–µ–Ω–Ω—ã–µ –æ–∫—Ä—É–∂–µ–Ω–∏—è –∏ –±–∞–∑–æ–≤–æ–µ –ª–æ–≥–∏—Ä–æ–≤–∞–Ω–∏–µ.
–ö—É—Ä—Å: TeleBot (pyTelegramBotAPI) + sqlite3 + python-dotenv, –∑–∞–ø—É—Å–∫ long polling.
"""

from __future__ import annotations
import os
import logging
from dotenv import load_dotenv

load_dotenv()

TOKEN: str | None = os.getenv("TOKEN")
DB_PATH: str = os.getenv("DB_PATH", "bot.db")

LOG_LEVEL_NAME = (os.getenv("LOG_LEVEL") or "INFO").upper()
LOG_LEVEL = getattr(logging, LOG_LEVEL_NAME, logging.INFO)

DEFAULT_NOTIFY_HOUR = int(os.getenv("DEFAULT_NOTIFY_HOUR", "9"))

logging.basicConfig(
    level=LOG_LEVEL,
    format="%(asctime)s [%(levelname)s] %(name)s: %(message)s"
)

if not TOKEN:
    raise RuntimeError("–ù–µ—Ç TOKEN –≤ .env ‚Äî –ø–æ–ª—É—á–∏—Ç–µ —Ç–æ–∫–µ–Ω —É @BotFather –∏ –ø–æ–ª–æ–∂–∏—Ç–µ –µ–≥–æ –≤ .env")

__all__ = ["TOKEN", "DB_PATH", "DEFAULT_NOTIFY_HOUR", "LOG_LEVEL"]


db.py
import os
import sqlite3

DB_PATH = os.getenv("DB_PATH", "bot.db")

def _connect():
    conn = sqlite3.connect(DB_PATH, timeout=5.0)
    conn.row_factory = sqlite3.Row
    conn.execute("PRAGMA foreign_keys = ON")
    conn.execute("PRAGMA journal_mode = WAL")
    conn.execute("PRAGMA busy_timeout = 5000")
    return conn

def init_db():
    schema = """
    CREATE TABLE IF NOT EXISTS notes (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    user_id INTEGER NOT NULL,
    text TEXT NOT NULL,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
    );
    CREATE TABLE IF NOT EXIST models(
    id INTEGER PRIMARY KEY,
    key TEXT NOT NULL UNIQUE,
    label TEXT NOT NULL,
    active INTEGER NOT NULL DEFAULT 0 CHECK (active IN (0,1))
    );
    CREATE NEW INDEX IF NOT EXIST ux_models_single_active ON models(active) WHERE active=1;

    INSERT OR IGNORE INTO models(id, key, label, active) VALUES
        (1, 'deepseek/deepseek-chat-v3.1:free', 'DeepSeek V3.1 (free)', 1),
        (2, 'deepseek/deepseek-r1:free', 'DeepSeek R1 (free)', 0),
        (3, 'mistralai/mistral-small-24b-instruct-2501:free', 'Mistral Small 24b (free)', 0),
        (4, 'meta-llama/llama-3.1-8b-instruct:free', 'Llama 3.1 8B (free)', 0);
    """
    with _connect() as conn:
        conn.executescript(schema)



def add_note(user_id: int, text: str) -> int:
    with _connect() as conn:
        cur = conn.execute(
            "INSERT INTO notes(user_id, text) VALUES (?, ?)",
            (user_id, text)
        )
    return cur.lastrowid


def list_notes(user_id: int, limit: int = 100):
    with _connect() as conn:
        cur = conn.execute(
            """SELECT id, text, created_at
            FROM notes
            WHERE user_id = ?
            ORDER BY id DESC
            LIMIT ?""",
            (user_id, limit)
        )
    return cur.fetchall()


def find_notes(user_id: int, query: str, limit: int = 50):
    """–ü–æ–∏—Å–∫ –∑–∞–º–µ—Ç–æ–∫ –ø–æ —Ç–µ–∫—Å—Ç—É"""
    with _connect() as conn:
        cur = conn.execute(
            """SELECT id, text, created_at
            FROM notes
            WHERE user_id = ? AND LOWER(text) LIKE LOWER(?)
            ORDER BY id DESC
            LIMIT ?""",
            (user_id, f"%{query}%", limit)
        )
    return cur.fetchall()


def get_note_by_id(user_id: int, note_id: int):
    """–ü–æ–ª—É—á–∏—Ç—å –æ–¥–Ω—É –∑–∞–º–µ—Ç–∫—É –ø–æ ID"""
    with _connect() as conn:
        cur = conn.execute(
            """SELECT id, text, created_at
            FROM notes
            WHERE user_id = ? AND id = ?""",
            (user_id, note_id)
        )
    return cur.fetchone()


def update_note(user_id: int, note_id: int, text: str) -> bool:
    with _connect() as conn:
        cur = conn.execute(
            """UPDATE notes
            SET text = ?
            WHERE user_id = ? AND id = ?""",
            (text, user_id, note_id)
        )
    return cur.rowcount > 0

def list_models() -> list[dict]:
    with _connect() as conn:
        rows = conn.execute("SELECT id,key,label,active FROM models ORDER BY id").fetchall()
        return [{"id":r["id"], "key":r["key"], "label":r["label"], "active":bool(r["active"])} for r in rows]

def get_active_model() -> dict:
    with _connect() as conn:
        row = conn.execute("SELECT id,key,label FROM models WHERE active=1").fetchone()
        if row:
            return {"id":row["id"], "key":row["key"], "label":row["label"], "active":True}
        row = conn.execute("SELECT id,key,label FROM models ORDER BY id LIMIT 1").fetchone()
        if not row:
            raise RuntimeError("–í —Ä–µ–µ—Å—Ç—Ä–µ –º–æ–¥–µ–ª–µ–π –Ω–µ—Ç –∑–∞–ø–∏—Å–µ–π")
        conn.execute("UPDATE models SET active=CASE WHEN id=? THEN 1 ELSE 0 END", (row["id"],))
        return {"id":row["id"], "key":row["key"], "label":row["label"], "active":True}

def set_active_model(model_id: int)-> dict:
    with _connect as conn:
        conn.execute("BEGIN IMMEDIATE")
        exists = conn.execute("SELECT 1 FROM models WHERE id=?", (model_id,)).fetchone()
        if not exists:
            conn.rollback()
            raise ValueError("–ù–µ–∏–∑–≤–µ—Å—Ç–Ω—ã–π ID –º–æ–¥–µ–ª–∏")
        conn.execute("UPDATE  models  SET active=CASE WHEN id=? THEN 1 ELSE 0 END", (model_id,))
        conn.commit()
    return get_active_model()

def delete_note(user_id: int, note_id: int) -> bool:
    with _connect() as conn:
        cur = conn.execute(
            "DELETE FROM notes WHERE user_id = ? AND id = ?",
            (user_id, note_id)
        )
    return cur.rowcount > 0

db3.py
"""
db.py ‚Äî —Å–ª–æ–π –¥–∞–Ω–Ω—ã—Ö –¥–ª—è DailyZodiakBot.

–¢–∞–±–ª–∏—Ü–∞ users:
  - user_id (PK)             ‚Äî Telegram user id
  - sign                     ‚Äî –∑–Ω–∞–∫ –∑–æ–¥–∏–∞–∫–∞ (—Å—Ç—Ä–æ–∫–∞ –∏–∑ —Å–ø–∏—Å–∫–∞)
  - notify_hour INTEGER      ‚Äî —á–∞—Å —Å—É—Ç–æ–∫ (0..23), –∫–æ–≥–¥–∞ —Å–ª–∞—Ç—å —Å–æ–æ–±—â–µ–Ω–∏–µ
  - subscribed INTEGER       ‚Äî 1/0 ‚Äî –ø–æ–¥–ø–∏—Å–∫–∞ –≤–∫–ª—é—á–µ–Ω–∞/–≤—ã–∫–ª—é—á–µ–Ω–∞
  - last_sent_date TEXT      ‚Äî 'YYYY-MM-DD', —á—Ç–æ–±—ã –Ω–µ —Å–ª–∞—Ç—å –ø–æ–≤—Ç–æ—Ä–Ω–æ –∑–∞ –¥–µ–Ω—å

–ü—Ä–∏—ë–º—ã:
  - –æ—Ç–¥–µ–ª—å–Ω–æ–µ –ø–æ–¥–∫–ª—é—á–µ–Ω–∏–µ –ø–æ–¥ –∫–∞–∂–¥—É—é –æ–ø–µ—Ä–∞—Ü–∏—é (with _connect());
  - PRAGMA: WAL + busy_timeout + row_factory=Row (—Å–º. –õ3) [oai_citation:5‚Ä°L3.pdf](file-service://file-TzQZFVK22mksuAGPBby5ME);
  - –≤—Å–µ SQL ‚Äî –ø–∞—Ä–∞–º–µ—Ç—Ä–∏–∑–æ–≤–∞–Ω–Ω—ã–µ —á–µ—Ä–µ–∑ "?" (–Ω–∏–∫–∞–∫–∏—Ö f-—Å—Ç—Ä–æ–∫).
"""

from __future__ import annotations
import sqlite3
import logging
from typing import Optional

from config3 import DB_PATH, DEFAULT_NOTIFY_HOUR

log = logging.getLogger(__name__)


# ---------- –ø–æ–¥–∫–ª—é—á–µ–Ω–∏–µ —Å ¬´–ø—Ä–∞–≤–∏–ª—å–Ω—ã–º–∏¬ª PRAGMA (—Å–º. –õ3) ----------
def _connect() -> sqlite3.Connection:
    conn = sqlite3.connect(DB_PATH, timeout=5.0)
    conn.row_factory = sqlite3.Row
    conn.execute("PRAGMA foreign_keys = ON")
    conn.execute("PRAGMA journal_mode = WAL")
    conn.execute("PRAGMA busy_timeout = 5000")
    return conn
# WAL + busy_timeout —É–º–µ–Ω—å—à–∞—é—Ç ¬´database is locked¬ª, row_factory –¥–∞—ë—Ç –¥–æ—Å—Ç—É–ø –∫ –ø–æ–ª—è–º –ø–æ –∏–º–µ–Ω–∏ [oai_citation:6‚Ä°L3.pdf](file-service://file-TzQZFVK22mksuAGPBby5ME)


# ---------- –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è —Å—Ö–µ–º—ã ----------
def init_db() -> None:
    """
    –°–æ–∑–¥–∞—ë—Ç —Ç–∞–±–ª–∏—Ü—É users, –µ—Å–ª–∏ –µ—ë –Ω–µ—Ç.
    –ü—Ä–æ—Å—Ç–µ–π—à–∏–µ —Ä–∞–∑—É–º–Ω—ã–µ –¥–µ—Ñ–æ–ª—Ç—ã; CHECK-–æ–≥—Ä–∞–Ω–∏—á–µ–Ω–∏—è –æ—Å—Ç–∞–≤–∏–º –Ω–∞ —Å—Ç–æ—Ä–æ–Ω–µ –ª–æ–≥–∏–∫–∏.
    """
    schema = """
    CREATE TABLE IF NOT EXISTS users (
        user_id        INTEGER PRIMARY KEY,
        sign           TEXT,
        notify_hour    INTEGER NOT NULL DEFAULT 9,
        subscribed     INTEGER NOT NULL DEFAULT 1,
        last_sent_date TEXT
    );

    CREATE INDEX IF NOT EXISTS idx_users_hour ON users(notify_hour);
    CREATE INDEX IF NOT EXISTS idx_users_sent ON users(last_sent_date);
    """
    with _connect() as conn:
        conn.executescript(schema)
    log.info("DB initialized: %s", DB_PATH)


# ---------- upsert/–ø–æ–ª—É—á–µ–Ω–∏–µ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è ----------
def ensure_user(user_id: int) -> None:
    """–ì–∞—Ä–∞–Ω—Ç–∏—Ä—É–µ–º –Ω–∞–ª–∏—á–∏–µ —Å—Ç—Ä–æ–∫–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è —Å –¥–µ—Ñ–æ–ª—Ç–∞–º–∏."""
    with _connect() as conn:
        conn.execute(
            "INSERT OR IGNORE INTO users(user_id, notify_hour, subscribed) VALUES (?, ?, 1)",
            (user_id, DEFAULT_NOTIFY_HOUR)
        )

def get_user(user_id: int) -> Optional[sqlite3.Row]:
    with _connect() as conn:
        cur = conn.execute("SELECT * FROM users WHERE user_id = ?", (user_id,))
        return cur.fetchone()


# ---------- –Ω–∞—Å—Ç—Ä–æ–π–∫–∏ –ø—Ä–æ—Ñ–∏–ª—è ----------
def set_sign(user_id: int, sign: str) -> None:
    with _connect() as conn:
        conn.execute("UPDATE users SET sign = ? WHERE user_id = ?", (sign, user_id))

def set_notify_hour(user_id: int, hour: int) -> None:
    hour = max(0, min(int(hour), 23))
    with _connect() as conn:
        conn.execute("UPDATE users SET notify_hour = ? WHERE user_id = ?", (hour, user_id))

def set_subscribed(user_id: int, on: bool) -> None:
    val = 1 if on else 0
    with _connect() as conn:
        conn.execute("UPDATE users SET subscribed = ? WHERE user_id = ?", (val, user_id))


# ---------- —Ä–∞—Å—Å—ã–ª–∫–∞: –≤—ã–±–æ—Ä–∫–∞ –∏ –æ—Ç–º–µ—Ç–∫–∞ –æ—Ç–ø—Ä–∞–≤–∫–∏ ----------
def list_due_users(today_str: str, hour: int) -> list[sqlite3.Row]:
    """
    –í–µ—Ä–Ω—ë—Ç –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π, –∫–æ–º—É –Ω–∞–¥–æ –æ—Ç–ø—Ä–∞–≤–∏—Ç—å: –ø–æ–¥–ø–∏—Å–∞–Ω, —á–∞—Å —Å–æ–≤–ø–∞–ª, –µ—â—ë –Ω–µ –æ—Ç–ø—Ä–∞–≤–ª—è–ª–∏ —Å–µ–≥–æ–¥–Ω—è, –∑–Ω–∞–∫ –∑–∞–¥–∞–Ω.
    """
    with _connect() as conn:
        cur = conn.execute(
            """
            SELECT user_id, sign
            FROM users
            WHERE subscribed = 1
              AND sign IS NOT NULL
              AND notify_hour = ?
              AND (last_sent_date IS NULL OR last_sent_date <> ?)
            """,
            (hour, today_str)
        )
        return cur.fetchall()

def mark_sent_today(user_id: int, today_str: str) -> None:
    with _connect() as conn:
        conn.execute("UPDATE users SET last_sent_date = ? WHERE user_id = ?", (today_str, user_id))

main.py
import os
import logging
import requests
from telebot import TeleBot, types
from dotenv import load_dotenv
from db import *

# –ó–∞–≥—Ä—É–∑–∫–∞ –ø–µ—Ä–µ–º–µ–Ω–Ω—ã—Ö –æ–∫—Ä—É–∂–µ–Ω–∏—è –∏ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –±–æ—Ç–∞
load_dotenv()
bot = TeleBot(os.getenv('TOKEN'))

# –ù–∞—Å—Ç—Ä–æ–π–∫–∞ –ª–æ–≥–∏—Ä–æ–≤–∞–Ω–∏—è –¥–ª—è –æ—Ç—Å–ª–µ–∂–∏–≤–∞–Ω–∏—è –¥–µ–π—Å—Ç–≤–∏–π –±–æ—Ç–∞
logging.basicConfig(
    level=logging.INFO,
    format="%(asctime)s - %(levelname)s - %(message)s"
)


# --- –í—Å–ø–æ–º–æ–≥–∞—Ç–µ–ª—å–Ω—ã–µ —Ñ—É–Ω–∫—Ü–∏–∏ ---

def parse_ints_from_text(text: str) -> list[int]:
    """
    –ò–∑–≤–ª–µ–∫–∞–µ—Ç —Ü–µ–ª—ã–µ —á–∏—Å–ª–∞ –∏–∑ —Ç–µ–∫—Å—Ç–∞, –ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞—è —Ä–∞–∑–Ω—ã–µ —Ä–∞–∑–¥–µ–ª–∏—Ç–µ–ª–∏.
    –ò–≥–Ω–æ—Ä–∏—Ä—É–µ—Ç –∫–æ–º–∞–Ω–¥—ã, –Ω–∞—á–∏–Ω–∞—é—â–∏–µ—Å—è —Å '/'.
    """
    # –ó–∞–º–µ–Ω—è–µ–º –∑–∞–ø—è—Ç—ã–µ –Ω–∞ –ø—Ä–æ–±–µ–ª—ã –¥–ª—è —É–Ω–∏—Ñ–∏–∫–∞—Ü–∏–∏
    text = text.replace(",", " ")
    # –†–∞–∑–±–∏–≤–∞–µ–º —Ç–µ–∫—Å—Ç –Ω–∞ —Ç–æ–∫–µ–Ω—ã –∏ –æ—Ç—Ñ–∏–ª—å—Ç—Ä–æ–≤—ã–≤–∞–µ–º –∫–æ–º–∞–Ω–¥—ã
    tokens = [t for t in text.split() if not t.startswith("/")]

    nums = []
    for t in tokens:
        # –£–±–∏—Ä–∞–µ–º –≤–æ–∑–º–æ–∂–Ω—ã–π –∑–Ω–∞–∫ –º–∏–Ω—É—Å–∞ –¥–ª—è –ø—Ä–æ–≤–µ—Ä–∫–∏ –Ω–∞ —á–∏—Å–ª–æ
        cleaned_token = t.strip().lstrip("-")
        if cleaned_token.isdigit():  # –ü—Ä–æ–≤–µ—Ä—è–µ–º, —è–≤–ª—è–µ—Ç—Å—è –ª–∏ —Ç–æ–∫–µ–Ω —á–∏—Å–ª–æ–º
            nums.append(int(t))
    return nums


def make_main_kb() -> types.ReplyKeyboardMarkup:
    """–°–æ–∑–¥–∞–µ—Ç –æ—Å–Ω–æ–≤–Ω—É—é Reply-–∫–ª–∞–≤–∏–∞—Ç—É—Ä—É —Å –∫–Ω–æ–ø–∫–∞–º–∏."""
    # –°–æ–∑–¥–∞—ë–º –∫–ª–∞–≤–∏–∞—Ç—É—Ä—É —Å –∞–≤—Ç–æ–ø–æ–¥–≥–æ–Ω–∫–æ–π —Ä–∞–∑–º–µ—Ä–∞
    kb = types.ReplyKeyboardMarkup(resize_keyboard=True)
    # –î–æ–±–∞–≤–ª—è–µ–º –∫–Ω–æ–ø–∫–∏ –ø–æ —Ä—è–¥–∞–º
    kb.row("–û –±–æ—Ç–µ", "–°—É–º–º–∞", "–ü–æ–≥–æ–¥–∞ (–ú–æ—Å–∫–≤–∞)")
    # –ù–û–í–´–ï –ö–ù–û–ü–ö–ò –ò–ó –î–û–ú–ê–®–ù–ï–ì–û –ó–ê–î–ê–ù–ò–Ø
    kb.row("/show", "/hide")
    kb.row("/help")
    return kb


# –°–ª–æ–≤–∞—Ä—å –¥–ª—è –∫–æ–¥–æ–≤ –ø–æ–≥–æ–¥—ã –æ—Ç Open-Meteo
WMO_DESC = {
    0: "–Ø—Å–Ω–æ", 1: "–í –æ—Å–Ω. —è—Å–Ω–æ", 2: "–ü–µ—Ä–µ–º–µ–Ω–Ω–∞—è –æ–±–ª–∞—á–Ω–æ—Å—Ç—å", 3: "–ü–∞—Å–º—É—Ä–Ω–æ",
    45: "–¢—É–º–∞–Ω", 48: "–ò–∑–º–æ—Ä–æ–∑—å", 51: "–ú–æ—Ä–æ—Å—å", 53: "–ú–æ—Ä–æ—Å—å", 55: "–°–∏–ª—å–Ω–∞—è –º–æ—Ä–æ—Å—å",
    61: "–î–æ–∂–¥—å", 63: "–î–æ–∂–¥—å", 65: "–°–∏–ª—å–Ω—ã–π –¥–æ–∂–¥—å", 71: "–°–Ω–µ–≥",
    80: "–õ–∏–≤–Ω–∏", 95: "–ì—Ä–æ–∑–∞"
}


def fetch_weather_moscow_open_meteo() -> str:
    """–ó–∞–ø—Ä–∞—à–∏–≤–∞–µ—Ç –∏ —Ñ–æ—Ä–º–∞—Ç–∏—Ä—É–µ—Ç –¥–∞–Ω–Ω—ã–µ –æ –ø–æ–≥–æ–¥–µ –¥–ª—è –ú–æ—Å–∫–≤—ã."""
    url = "https://api.open-meteo.com/v1/forecast"
    params = {
        "latitude": 55.7558, "longitude": 37.6173,
        "current": "temperature_2m,weather_code",
        "timezone": "Europe/Moscow"
    }
    try:
        r = requests.get(url, params=params, timeout=5)
        r.raise_for_status()
        data = r.json()
        cur = data["current"]
        temp = round(cur["temperature_2m"])
        code = int(cur.get("weather_code", 0))
        return f"–ú–æ—Å–∫–≤–∞: —Å–µ–π—á–∞—Å {temp}¬∞C, {WMO_DESC.get(code, '–Ω–µ—Ç –¥–∞–Ω–Ω—ã—Ö –æ –ø–æ–≥–æ–¥–µ')}"
    except requests.exceptions.RequestException:
        return "–ù–µ —É–¥–∞–ª–æ—Å—å –ø–æ–ª—É—á–∏—Ç—å –ø–æ–≥–æ–¥—É (—Å–µ—Ç—å)."
    except (KeyError, TypeError, ValueError):
        return "–û—Ç–≤–µ—Ç –ø–æ–≥–æ–¥—ã –≤ –Ω–µ–æ–∂–∏–¥–∞–µ–º–æ–º —Ñ–æ—Ä–º–∞—Ç–µ."


# --- –û–±—Ä–∞–±–æ—Ç—á–∏–∫–∏ –∫–æ–º–∞–Ω–¥ –∏ —Å–æ–æ–±—â–µ–Ω–∏–π ---

@bot.message_handler(commands=['start', 'help'])
def start_help(m: types.Message):
    """–û–±—Ä–∞–±–æ—Ç—á–∏–∫ –∫–æ–º–∞–Ω–¥ /start –∏ /help, –æ—Ç–ø—Ä–∞–≤–ª—è–µ—Ç –ø—Ä–∏–≤–µ—Ç—Å—Ç–≤–∏–µ –∏ –∫–ª–∞–≤–∏–∞—Ç—É—Ä—É."""
    welcome_text = (
        "–ü—Ä–∏–≤–µ—Ç! –Ø —Ç–µ—Å—Ç–æ–≤—ã–π –±–æ—Ç. "
        "–ù–∞–∂–º–∏ –Ω–∞ –æ–¥–Ω—É –∏–∑ –∫–Ω–æ–ø–æ–∫ –≤ –º–µ–Ω—é –¥–ª—è –≤–∑–∞–∏–º–æ–¥–µ–π—Å—Ç–≤–∏—è."
    )
    bot.send_message(m.chat.id, welcome_text, reply_markup=make_main_kb())


# --- –ù–û–í–ê–Ø –ö–û–ú–ê–ù–î–ê /max –ò–ó –î–û–ú–ê–®–ù–ï–ì–û –ó–ê–î–ê–ù–ò–Ø ---
@bot.message_handler(commands=['max'])
def cmd_max(m: types.Message):
    """–ù–∞—Ö–æ–¥–∏—Ç –º–∞–∫—Å–∏–º–∞–ª—å–Ω–æ–µ —á–∏—Å–ª–æ –∏–∑ –ø–µ—Ä–µ–¥–∞–Ω–Ω—ã—Ö."""
    logging.info(f"/max –æ—Ç {m.from_user.first_name} ({m.from_user.id}): {m.text}")
    nums = parse_ints_from_text(m.text)
    logging.info(f"–†–∞—Å–ø–æ–∑–Ω–∞–Ω—ã —á–∏—Å–ª–∞: {nums}")

    if not nums:
        bot.reply_to(m, "–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, —É–∫–∞–∂–∏—Ç–µ —á–∏—Å–ª–∞ —á–µ—Ä–µ–∑ –ø—Ä–æ–±–µ–ª –∏–ª–∏ –∑–∞–ø—è—Ç—É—é. –ü—Ä–∏–º–µ—Ä: /max 2 3 10")
    else:
        bot.reply_to(m, f"–ú–∞–∫—Å–∏–º—É–º: {max(nums)}")


@bot.message_handler(commands=['sum'])
def cmd_sum(m: types.Message):
    """–°—É–º–º–∏—Ä—É–µ—Ç —á–∏—Å–ª–∞, –ø–µ—Ä–µ–¥–∞–Ω–Ω—ã–µ –≤ —Å–æ–æ–±—â–µ–Ω–∏–∏."""
    logging.info(f"/sum –æ—Ç {m.from_user.first_name} ({m.from_user.id}): {m.text}")
    nums = parse_ints_from_text(m.text)
    logging.info(f"–†–∞—Å–ø–æ–∑–Ω–∞–Ω—ã —á–∏—Å–ª–∞: {nums}")
    bot.reply_to(m, f"–°—É–º–º–∞: {sum(nums)}" if nums else "–ü—Ä–∏–º–µ—Ä: /sum 2 3 10")


# --- –û–ë–ù–û–í–õ–ï–ù–ù–´–ï –ö–û–ú–ê–ù–î–´ –î–õ–Ø –†–ê–ë–û–¢–´ –° –ö–õ–ê–í–ò–ê–¢–£–†–û–ô ---
@bot.message_handler(commands=['hide'])
def hide_kb(m: types.Message):
    """–ü—Ä—è—á–µ—Ç Reply-–∫–ª–∞–≤–∏–∞—Ç—É—Ä—É."""
    rm = types.ReplyKeyboardRemove()
    bot.send_message(m.chat.id, "–°–ø—Ä—è—Ç–∞–ª –∫–ª–∞–≤–∏–∞—Ç—É—Ä—É.", reply_markup=rm)


@bot.message_handler(commands=['show'])
def show_kb(m: types.Message):
    """–ü–æ–∫–∞–∑—ã–≤–∞–µ—Ç Reply-–∫–ª–∞–≤–∏–∞—Ç—É—Ä—É."""
    bot.send_message(m.chat.id, "–í–æ—Ç –∫–ª–∞–≤–∏–∞—Ç—É—Ä–∞:", reply_markup=make_main_kb())


# --- –û–ë–ù–û–í–õ–ï–ù–ù–ê–Ø –ö–û–ú–ê–ù–î–ê /confirm –ò–ó –î–û–ú–ê–®–ù–ï–ì–û –ó–ê–î–ê–ù–ò–Ø ---
@bot.message_handler(commands=['confirm'])
def confirm_cmd(m: types.Message):
    """–û—Ç–ø—Ä–∞–≤–ª—è–µ—Ç Inline-–∫–Ω–æ–ø–∫–∏ –¥–ª—è –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏—è."""
    kb = types.InlineKeyboardMarkup()
    kb.add(
        types.InlineKeyboardButton("–î–∞", callback_data="save:yes"),
        types.InlineKeyboardButton("–ù–µ—Ç", callback_data="save:no"),
        # –ù–æ–≤–∞—è –∫–Ω–æ–ø–∫–∞ "–û—Ç–º–µ–Ω–∞"
        types.InlineKeyboardButton("–û—Ç–º–µ–Ω–∞", callback_data="save:later"),
    )
    # –û–±–Ω–æ–≤–ª–µ–Ω–Ω—ã–π —Ç–µ–∫—Å—Ç —Å–æ–æ–±—â–µ–Ω–∏—è
    bot.send_message(m.chat.id, "–°–æ—Ö—Ä–∞–Ω–∏—Ç—å –∏–∑–º–µ–Ω–µ–Ω–∏—è?", reply_markup=kb)


# --- –û–ë–ù–û–í–õ–ï–ù–ù–´–ô –û–ë–†–ê–ë–û–¢–ß–ò–ö –î–õ–Ø INLINE-–ö–ù–û–ü–û–ö ---
@bot.callback_query_handler(func=lambda c: c.data.startswith("save:"))
def on_confirm(c: types.CallbackQuery):
    """–û–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ—Ç –Ω–∞–∂–∞—Ç–∏—è –Ω–∞ Inline-–∫–Ω–æ–ø–∫–∏."""
    # –ò–∑–≤–ª–µ–∫–∞–µ–º –≤—ã–±–æ—Ä –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
    choice = c.data.split(":", 1)[1]

    # –û—Ç–ø—Ä–∞–≤–ª—è–µ–º "—á–∞—Å–∏–∫–∏" –Ω–∞ –Ω–∞–∂–∞—Ç–æ–π –∫–Ω–æ–ø–∫–µ
    bot.answer_callback_query(c.id, "–ü—Ä–∏–Ω—è—Ç–æ!")

    # –£–±–∏—Ä–∞–µ–º inline-–∫–Ω–æ–ø–∫–∏ –∏–∑ —Å–æ–æ–±—â–µ–Ω–∏—è
    bot.edit_message_reply_markup(c.message.chat.id, c.message.message_id, reply_markup=None)

    # –û—Ç–ø—Ä–∞–≤–ª—è–µ–º —Ä–µ–∑—É–ª—å—Ç–∞—Ç –≤ –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–∏ –æ—Ç –≤—ã–±–æ—Ä–∞
    if choice == "yes":
        bot.send_message(c.message.chat.id, "–ì–æ—Ç–æ–≤–æ!")
    elif choice == "no":
        bot.send_message(c.message.chat.id, "–û—Ç–º–µ–Ω–µ–Ω–æ.")
    elif choice == "later":
        bot.send_message(c.message.chat.id, "–û—Ç–ª–æ–∂–µ–Ω–æ.")


# --- –û–±—Ä–∞–±–æ—Ç—á–∏–∫–∏ –∫–Ω–æ–ø–æ–∫ Reply-–∫–ª–∞–≤–∏–∞—Ç—É—Ä—ã ---
@bot.message_handler(func=lambda m: m.text == "–û –±–æ—Ç–µ")
def kb_about(m: types.Message):
    bot.reply_to(m, "–Ø —É–º–µ—é: /start, /help, /sum, /max, /hide, /show, /confirm")


@bot.message_handler(func=lambda m: m.text == "–°—É–º–º–∞")
def kb_sum(m: types.Message):
    """–ó–∞–ø—É—Å–∫–∞–µ—Ç —Å—Ü–µ–Ω–∞—Ä–∏–π —Å—É–º–º–∏—Ä–æ–≤–∞–Ω–∏—è —á–∏—Å–µ–ª."""
    bot.send_message(m.chat.id, "–í–≤–µ–¥–∏—Ç–µ —á–∏—Å–ª–∞ —á–µ—Ä–µ–∑ –ø—Ä–æ–±–µ–ª –∏–ª–∏ –∑–∞–ø—è—Ç—É—é:")
    bot.register_next_step_handler(m, on_sum_numbers)


def on_sum_numbers(m: types.Message):
    """–ü–æ–ª—É—á–∞–µ—Ç —á–∏—Å–ª–∞ –∏ —Å—á–∏—Ç–∞–µ—Ç —Å—É–º–º—É."""
    nums = parse_ints_from_text(m.text)
    if not nums:
        bot.reply_to(m, "–ù–µ –≤–∏–∂—É —á–∏—Å–µ–ª. –ü—Ä–∏–º–µ—Ä: 2 3 10 –∏–ª–∏ 2, 3, -5")
    else:
        bot.reply_to(m, f"–°—É–º–º–∞: {sum(nums)}")


@bot.message_handler(func=lambda m: m.text == "–ü–æ–≥–æ–¥–∞ (–ú–æ—Å–∫–≤–∞)")
def kb_weather_moscow(m: types.Message):
    """–û—Ç–ø—Ä–∞–≤–ª—è–µ—Ç –ø–æ–≥–æ–¥—É –¥–ª—è –ú–æ—Å–∫–≤—ã –ø–æ –Ω–∞–∂–∞—Ç–∏—é –∫–Ω–æ–ø–∫–∏."""
    bot.send_message(m.chat.id, fetch_weather_moscow_open_meteo())

@bot.message_handler(commands=["models"])
def cmd_models(message: types.Message) -> None:
    items = list_models()
    if not items:
        bot.reply_to(message, "–°–ø–∏—Å–æ–∫ –º–æ–¥–µ–ª–µ–π –ø—É—Å—Ç.")
        return
    lines = ["–î–æ—Å—Ç—É–ø–Ω—ã–µ –º–æ–¥–µ–ª–∏:"]
    for m in items:
        star = "‚òÖ" if m["active"] else " "
        lines.append(f"{star} {m['id']}. {m['label']}  [{m['key']}]")
    lines.append("\n–ê–∫—Ç–∏–≤–∏—Ä–æ–≤–∞—Ç—å: /model <ID>")
    bot.reply_to(message, "\n".join(lines))

@bot.message_handler(commands=['model'])
def cmd_model(message: types.Message)->None:
    arg = message.text.replace("/model" , "" , 1).strip()
    if not arg:
        active = get_active_model()
        bot.reply_to(message , f"–¢–µ–∫—É—â–∞—è –∞–∫—Ç–∏–≤–Ω–∞—è –º–æ–µ–¥–ª—å: {active['label']} [{active['key']}]\n(—Å–º–µ–Ω–∏—Ç—å: /model <ID> –∏–ª–∏ /models)")
        return
    if not arg.isdigit():
        bot.reply_to(message, "–ò—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ: /model <ID –∏–∑ /models>")
        return
    try:
        active = set_active_model(int(arg))
        bot.reply_to(message, f"–ê–∫—Ç–∏–≤–Ω–∞—è –º–æ–¥–µ–ª—å –ø–µ—Ä–µ–∫–ª—é—á–µ–Ω–∞: {active['label']} [{active["key"]}]")
    except ValueError:
        bot.reply_to(message, "–ù–µ–∏–∑–≤–µ—Å—Ç–Ω—ã–π ID –º–æ–¥–µ–ª–∏. –°–Ω–∞—á–∞–ª–∞ /models.")


@bot.message_handler(commands=['start', 'help'])
def cmd_start(message: types.Message) -> None:
    """

    """
    text = (
        "–ø—Ä–∏–≤–µ—Ç! —ç—Ç–æ –∑–∞–º–µ—Ç–æ—á–Ω–∏–∫ –Ω–∞ SQLite. \n\n"
        "–∫–æ–º–∞–Ω–¥–∞: \n"
        "/note_add <—Ç–µ–∫—Å—Ç>\n"
        "/note_list [N]\n"
        "/note_find <–ø–æ–¥—Å—Ç—Ä–æ–∫–∞>\n"
        "/note_edit <id> <—Ç–µ–∫—Å—Ç>\n"
        "/note_del <id>\n"
        "/note_count\n"
        "/note_export\n"
        "note_stats [days]\n"
        "/models\n"
        "/model <id>\n"
    )

# --- –û—Å–Ω–æ–≤–Ω–æ–π —Ü–∏–∫–ª ---
if __name__ == '__main__':
    logging.info("–ë–æ—Ç –∑–∞–ø—É—â–µ–Ω")
    bot.infinity_polling(skip_pending=True)

main2.py
import os
from dotenv import load_dotenv
import telebot
import time
import db
from datetime import datetime

# –ó–∞–≥—Ä—É–∑–∫–∞ –ø–µ—Ä–µ–º–µ–Ω–Ω—ã—Ö –æ–∫—Ä—É–∂–µ–Ω–∏—è
load_dotenv()
TOKEN = os.getenv("TOKEN")
if not TOKEN:
    raise RuntimeError("–í .env —Ñ–∞–π–ª–µ –Ω–µ—Ç TOKEN")

bot = telebot.TeleBot(TOKEN)

# –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –±–∞–∑—ã –¥–∞–Ω–Ω—ã—Ö –ø—Ä–∏ –∑–∞–ø—É—Å–∫–µ
db.init_db()


@bot.message_handler(commands=['start'])
def start(message):
    welcome_text = f"""
üëã –ü—Ä–∏–≤–µ—Ç, {message.from_user.first_name}!

–Ø –±–æ—Ç –¥–ª—è –∑–∞–º–µ—Ç–æ–∫. –Ø –ø–æ–º–æ–≥—É —Ç–µ–±–µ —Å–æ—Ö—Ä–∞–Ω—è—Ç—å –≤–∞–∂–Ω—É—é –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é.
–í—Å–µ —Ç–≤–æ–∏ –∑–∞–º–µ—Ç–∫–∏ —Ö—Ä–∞–Ω—è—Ç—Å—è –≤ –±–∞–∑–µ –¥–∞–Ω–Ω—ã—Ö –∏ –¥–æ—Å—Ç—É–ø–Ω—ã —Ç–æ–ª—å–∫–æ —Ç–µ–±–µ.

–ò—Å–ø–æ–ª—å–∑—É–π /help –¥–ª—è —Å–ø–∏—Å–∫–∞ –∫–æ–º–∞–Ω–¥.
"""
    bot.reply_to(message, welcome_text)


@bot.message_handler(commands=['help'])
def help_cmd(message):
    help_text = """
üìù **–î–æ—Å—Ç—É–ø–Ω—ã–µ –∫–æ–º–∞–Ω–¥—ã:**

/note\_add `<—Ç–µ–∫—Å—Ç>` - –î–æ–±–∞–≤–∏—Ç—å –∑–∞–º–µ—Ç–∫—É
/note\_list - –ü–æ–∫–∞–∑–∞—Ç—å –≤—Å–µ –∑–∞–º–µ—Ç–∫–∏
/note\_find `<–∑–∞–ø—Ä–æ—Å>` - –ù–∞–π—Ç–∏ –∑–∞–º–µ—Ç–∫—É
/note\_show `<id>` - –ü–æ–∫–∞–∑–∞—Ç—å –ø–æ–ª–Ω—É—é –∑–∞–º–µ—Ç–∫—É
/note\_edit `<id>` `<–Ω–æ–≤—ã–π —Ç–µ–∫—Å—Ç>` - –ò–∑–º–µ–Ω–∏—Ç—å –∑–∞–º–µ—Ç–∫—É
/note\_del `<id>` - –£–¥–∞–ª–∏—Ç—å –∑–∞–º–µ—Ç–∫—É

üí° **–ü—Ä–∏–º–µ—Ä—ã:**
/note\_add –ö—É–ø–∏—Ç—å –º–æ–ª–æ–∫–æ
/note\_find –º–æ–ª–æ–∫–æ
/note\_edit 5 –ö—É–ø–∏—Ç—å –º–æ–ª–æ–∫–æ –∏ —Ö–ª–µ–±
/note\_del 5
"""
    bot.reply_to(message, help_text, parse_mode='Markdown')


@bot.message_handler(commands=['note_add'])
def note_add(message):
    parts = message.text.split(maxsplit=1)
    if len(parts) < 2 or not parts[1].strip():
        bot.reply_to(message, "‚ùå –§–æ—Ä–º–∞—Ç: /note_add <—Ç–µ–∫—Å—Ç –∑–∞–º–µ—Ç–∫–∏>")
        return

    text = parts[1].strip()

    try:
        note_id = db.add_note(message.from_user.id, text)
        bot.reply_to(message, f"‚úÖ –ó–∞–º–µ—Ç–∫–∞ #{note_id} –¥–æ–±–∞–≤–ª–µ–Ω–∞:\n\n{text}")
    except Exception as e:
        bot.reply_to(message, f"‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ –¥–æ–±–∞–≤–ª–µ–Ω–∏–∏ –∑–∞–º–µ—Ç–∫–∏: {str(e)}")


@bot.message_handler(commands=['note_list'])
def note_list(message):
    try:
        notes = db.list_notes(message.from_user.id)

        if not notes:
            bot.reply_to(message, "üì≠ –£ –≤–∞—Å –ø–æ–∫–∞ –Ω–µ—Ç –∑–∞–º–µ—Ç–æ–∫.\n–ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ /note_add <—Ç–µ–∫—Å—Ç> –¥–ª—è –¥–æ–±–∞–≤–ª–µ–Ω–∏—è.")
            return

        response = f"üìã **–í–∞—à–∏ –∑–∞–º–µ—Ç–∫–∏** (–ø–æ—Å–ª–µ–¥–Ω–∏–µ {len(notes)}):\n\n"

        for note in notes:
            # –§–æ—Ä–º–∞—Ç–∏—Ä—É–µ–º –¥–∞—Ç—É
            created_at = datetime.fromisoformat(note['created_at']).strftime('%d.%m.%Y %H:%M')
            # –û–≥—Ä–∞–Ω–∏—á–∏–≤–∞–µ–º –¥–ª–∏–Ω—É —Ç–µ–∫—Å—Ç–∞ –¥–ª—è —Å–ø–∏—Å–∫–∞
            text = note['text']
            display_text = text[:50] + "..." if len(text) > 50 else text
            response += f"#{note['id']} _{created_at}_\n{display_text}\n\n"

        # Telegram –∏–º–µ–µ—Ç –ª–∏–º–∏—Ç –Ω–∞ –¥–ª–∏–Ω—É —Å–æ–æ–±—â–µ–Ω–∏—è
        if len(response) > 4000:
            response = response[:3900] + "\n\n... _—Å–ø–∏—Å–æ–∫ –æ–±—Ä–µ–∑–∞–Ω_"

        bot.reply_to(message, response, parse_mode='Markdown')
    except Exception as e:
        bot.reply_to(message, f"‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ –ø–æ–ª—É—á–µ–Ω–∏–∏ –∑–∞–º–µ—Ç–æ–∫: {str(e)}")


@bot.message_handler(commands=['note_find'])
def note_find(message):
    parts = message.text.split(maxsplit=1)
    if len(parts) < 2:
        bot.reply_to(message, "‚ùå –§–æ—Ä–º–∞—Ç: /note_find <–ø–æ–∏—Å–∫–æ–≤—ã–π –∑–∞–ø—Ä–æ—Å>")
        return

    query = parts[1].strip()

    try:
        notes = db.find_notes(message.from_user.id, query)

        if not notes:
            bot.reply_to(message, f"üîç –ó–∞–º–µ—Ç–∫–∏ –ø–æ –∑–∞–ø—Ä–æ—Å—É '{query}' –Ω–µ –Ω–∞–π–¥–µ–Ω—ã.")
            return

        response = f"üîç **–ù–∞–π–¥–µ–Ω–æ –∑–∞–º–µ—Ç–æ–∫:** {len(notes)}\n–ü–æ –∑–∞–ø—Ä–æ—Å—É: _{query}_\n\n"

        for note in notes:
            created_at = datetime.fromisoformat(note['created_at']).strftime('%d.%m.%Y %H:%M')
            text = note['text']
            # –ü–æ–¥—Å–≤–µ—á–∏–≤–∞–µ–º –Ω–∞–π–¥–µ–Ω–Ω—ã–π —Ç–µ–∫—Å—Ç
            display_text = text[:100] + "..." if len(text) > 100 else text
            response += f"#{note['id']} _{created_at}_\n{display_text}\n\n"

        if len(response) > 4000:
            response = response[:3900] + "\n\n... _—Å–ø–∏—Å–æ–∫ –æ–±—Ä–µ–∑–∞–Ω_"

        bot.reply_to(message, response, parse_mode='Markdown')
    except Exception as e:
        bot.reply_to(message, f"‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ –ø–æ–∏—Å–∫–µ: {str(e)}")


@bot.message_handler(commands=['note_show'])
def note_show(message):
    parts = message.text.split()
    if len(parts) < 2:
        bot.reply_to(message, "‚ùå –§–æ—Ä–º–∞—Ç: /note_show <id>")
        return

    try:
        note_id = int(parts[1])
    except ValueError:
        bot.reply_to(message, "‚ùå ID –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å —á–∏—Å–ª–æ–º.")
        return

    try:
        note = db.get_note_by_id(message.from_user.id, note_id)

        if note:
            created_at = datetime.fromisoformat(note['created_at']).strftime('%d.%m.%Y %H:%M')
            response = f"üìù **–ó–∞–º–µ—Ç–∫–∞ #{note['id']}**\n"
            response += f"_–°–æ–∑–¥–∞–Ω–∞: {created_at}_\n\n"
            response += note['text']
            bot.reply_to(message, response, parse_mode='Markdown')
        else:
            bot.reply_to(message, f"‚ùå –ó–∞–º–µ—Ç–∫–∞ #{note_id} –Ω–µ –Ω–∞–π–¥–µ–Ω–∞.")
    except Exception as e:
        bot.reply_to(message, f"‚ùå –û—à–∏–±–∫–∞: {str(e)}")


@bot.message_handler(commands=['note_edit'])
def note_edit(message):
    parts = message.text.split(maxsplit=2)
    if len(parts) < 3:
        bot.reply_to(message, "‚ùå –§–æ—Ä–º–∞—Ç: /note_edit <id> <–Ω–æ–≤—ã–π —Ç–µ–∫—Å—Ç>")
        return

    try:
        note_id = int(parts[1])
        new_text = parts[2].strip()
    except ValueError:
        bot.reply_to(message, "‚ùå ID –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å —á–∏—Å–ª–æ–º.")
        return

    if not new_text:
        bot.reply_to(message, "‚ùå –¢–µ–∫—Å—Ç –∑–∞–º–µ—Ç–∫–∏ –Ω–µ –º–æ–∂–µ—Ç –±—ã—Ç—å –ø—É—Å—Ç—ã–º.")
        return

    try:
        if db.update_note(message.from_user.id, note_id, new_text):
            bot.reply_to(message, f"‚úÖ –ó–∞–º–µ—Ç–∫–∞ #{note_id} –∏–∑–º–µ–Ω–µ–Ω–∞:\n\n{new_text}")
        else:
            bot.reply_to(message, f"‚ùå –ó–∞–º–µ—Ç–∫–∞ #{note_id} –Ω–µ –Ω–∞–π–¥–µ–Ω–∞ –∏–ª–∏ –Ω–µ –ø—Ä–∏–Ω–∞–¥–ª–µ–∂–∏—Ç –≤–∞–º.")
    except Exception as e:
        bot.reply_to(message, f"‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ —Ä–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞–Ω–∏–∏: {str(e)}")


@bot.message_handler(commands=['note_del'])
def note_del(message):
    parts = message.text.split()
    if len(parts) < 2:
        bot.reply_to(message, "‚ùå –§–æ—Ä–º–∞—Ç: /note_del <id>")
        return

    try:
        note_id = int(parts[1])
    except ValueError:
        bot.reply_to(message, "‚ùå ID –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å —á–∏—Å–ª–æ–º.")
        return

    try:
        if db.delete_note(message.from_user.id, note_id):
            bot.reply_to(message, f"‚úÖ –ó–∞–º–µ—Ç–∫–∞ #{note_id} —É–¥–∞–ª–µ–Ω–∞.")
        else:
            bot.reply_to(message, f"‚ùå –ó–∞–º–µ—Ç–∫–∞ #{note_id} –Ω–µ –Ω–∞–π–¥–µ–Ω–∞ –∏–ª–∏ –Ω–µ –ø—Ä–∏–Ω–∞–¥–ª–µ–∂–∏—Ç –≤–∞–º.")
    except Exception as e:
        bot.reply_to(message, f"‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ —É–¥–∞–ª–µ–Ω–∏–∏: {str(e)}")

@bot.message_handler(commands=['note_count'])
def note_count(message):
    try:
        count = db.count_notes(message.from_user.id)
        bot.reply_to(message, f"üìä –£ –≤–∞—Å –≤—Å–µ–≥–æ {count} –∑–∞–º–µ—Ç–æ–∫.")
    except Exception as e:
        bot.reply_to(message, f"‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ –ø–æ–¥—Å—á–µ—Ç–µ –∑–∞–º–µ—Ç–æ–∫: {str(e)}")


@bot.message_handler(func=lambda message: True)
def echo_all(message):
    bot.reply_to(message, "‚ùì –ù–µ–∏–∑–≤–µ—Å—Ç–Ω–∞—è –∫–æ–º–∞–Ω–¥–∞. –ò—Å–ø–æ–ª—å–∑—É–π /help –¥–ª—è —Å–ø–∏—Å–∫–∞ –∫–æ–º–∞–Ω–¥.")


if __name__ == "__main__":
    print("ü§ñ –ë–æ—Ç –∑–∞–ø—É—Å–∫–∞–µ—Ç—Å—è...")
    print("‚úÖ –ë–∞–∑–∞ –¥–∞–Ω–Ω—ã—Ö –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω–∞")
    print(f"üìÅ –ü—É—Ç—å –∫ –ë–î: {os.getenv('DB_PATH', 'bot.db')}")
    print("üì° –ù–∞—á–∏–Ω–∞—é –ø–æ–ª—É—á–µ–Ω–∏–µ –æ–±–Ω–æ–≤–ª–µ–Ω–∏–π...")

    while True:
        try:
            bot.polling(none_stop=True, interval=0, timeout=20)
        except Exception as e:
            print(f"‚ùå –û—à–∏–±–∫–∞: {e}")
            time.sleep(5)

main3.py
"""
main.py ‚Äî DailyZodiakBot (—Ä–∞–∑–≤–ª–µ–∫–∞—Ç–µ–ª—å–Ω—ã–π –∫–æ–Ω—Ç–µ–Ω—Ç –±–µ–∑ –≤–Ω–µ—à–Ω–∏—Ö API).

–ö–æ–º–∞–Ω–¥—ã:
  /start                  ‚Äî —Ä–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏—è, –≤—ã–±–æ—Ä –∑–Ω–∞–∫–∞ –∏ —á–∞—Å–∞
  /set_sign <–∑–Ω–∞–∫>        ‚Äî —É—Å—Ç–∞–Ω–æ–≤–∏—Ç—å –∑–Ω–∞–∫ (–∏–ª–∏ –Ω–∞–∂–∞—Ç—å –∫–Ω–æ–ø–∫—É —Å –Ω–∞–∑–≤–∞–Ω–∏–µ–º)
  /set_time <0..23>       ‚Äî —á–∞—Å —É—Ç—Ä–∞/–¥–Ω—è –¥–ª—è —Ä–∞—Å—Å—ã–ª–∫–∏ (–ø–æ –≤—Ä–µ–º–µ–Ω–∏ —Å–µ—Ä–≤–µ—Ä–∞)
  /subscribe              ‚Äî –≤–∫–ª—é—á–∏—Ç—å –ø–æ–¥–ø–∏—Å–∫—É
  /unsubscribe            ‚Äî –≤—ã–∫–ª—é—á–∏—Ç—å –ø–æ–¥–ø–∏—Å–∫—É
  /me                     ‚Äî –º–æ–∏ –Ω–∞—Å—Ç—Ä–æ–π–∫–∏
  /today                  ‚Äî –≤—ã—Å–ª–∞—Ç—å ¬´–≥–æ—Ä–æ—Å–∫–æ–ø –¥–Ω—è¬ª –ø—Ä—è–º–æ —Å–µ–π—á–∞—Å
  /signs                  ‚Äî –ø–æ–∫–∞–∑–∞—Ç—å —Å–ø–∏—Å–æ–∫ –∑–Ω–∞–∫–æ–≤

–†–∞—Å—Å—ã–ª–∫–∞:
  - —Ñ–æ–Ω–æ–≤—ã–π –ø–æ—Ç–æ–∫ –ø—Ä–æ–≤–µ—Ä—è–µ—Ç —Ä–∞–∑ –≤ –º–∏–Ω—É—Ç—É: –∫–æ–º—É –æ—Ç–ø—Ä–∞–≤–∏—Ç—å —Å–µ–π—á–∞—Å;
  - —É—Å–ª–æ–≤–∏–µ: subscribed=1, notify_hour == now.hour, last_sent_date != today.
"""

from __future__ import annotations
import logging
import threading
import time
import hashlib
from datetime import datetime, date

import telebot
from telebot import types

import db3 as db
from config3 import TOKEN, DEFAULT_NOTIFY_HOUR

log = logging.getLogger(__name__)

bot = telebot.TeleBot(TOKEN)
db.init_db()  # —Å–æ–∑–¥–∞—ë–º —Å—Ö–µ–º—ã, –µ—Å–ª–∏ –∏—Ö –Ω–µ—Ç

# ---------- —Å–ø—Ä–∞–≤–æ—á–Ω–∏–∫ –∑–Ω–∞–∫–æ–≤: –∫–∞–Ω–æ–Ω, —Å–∏–Ω–æ–Ω–∏–º—ã, —ç–º–æ–¥–∑–∏ ----------
CANON_SIGNS = [
    "–æ–≤–µ–Ω", "—Ç–µ–ª–µ—Ü", "–±–ª–∏–∑–Ω–µ—Ü—ã", "—Ä–∞–∫", "–ª–µ–≤", "–¥–µ–≤–∞",
    "–≤–µ—Å—ã", "—Å–∫–æ—Ä–ø–∏–æ–Ω", "—Å—Ç—Ä–µ–ª–µ—Ü", "–∫–æ–∑–µ—Ä–æ–≥", "–≤–æ–¥–æ–ª–µ–π", "—Ä—ã–±—ã"
]
SIGN_EMOJI = {
    "–æ–≤–µ–Ω":"‚ôà", "—Ç–µ–ª–µ—Ü":"‚ôâ", "–±–ª–∏–∑–Ω–µ—Ü—ã":"‚ôä", "—Ä–∞–∫":"‚ôã", "–ª–µ–≤":"‚ôå", "–¥–µ–≤–∞":"‚ôç",
    "–≤–µ—Å—ã":"‚ôé", "—Å–∫–æ—Ä–ø–∏–æ–Ω":"‚ôè", "—Å—Ç—Ä–µ–ª–µ—Ü":"‚ôê", "–∫–æ–∑–µ—Ä–æ–≥":"‚ôë", "–≤–æ–¥–æ–ª–µ–π":"‚ôí", "—Ä—ã–±—ã":"‚ôì"
}
# –ü—Ä–∏–º–∏—Ç–∏–≤–Ω—ã–µ –∞–Ω–≥–ª. —Å–∏–Ω–æ–Ω–∏–º—ã ‚Äî —á—Ç–æ–±—ã –Ω–µ —Å–ø–æ—Ç—ã–∫–∞–ª–∏—Å—å:
SIGN_ALIASES = {
    "aries":"–æ–≤–µ–Ω", "taurus":"—Ç–µ–ª–µ—Ü", "gemini":"–±–ª–∏–∑–Ω–µ—Ü—ã", "cancer":"—Ä–∞–∫", "leo":"–ª–µ–≤", "virgo":"–¥–µ–≤–∞",
    "libra":"–≤–µ—Å—ã", "scorpio":"—Å–∫–æ—Ä–ø–∏–æ–Ω", "sagittarius":"—Å—Ç—Ä–µ–ª–µ—Ü", "capricorn":"–∫–æ–∑–µ—Ä–æ–≥", "aquarius":"–≤–æ–¥–æ–ª–µ–π", "pisces":"—Ä—ã–±—ã"
}

def normalize_sign(text: str) -> str | None:
    t = (text or "").strip().lower()
    t = t.replace("—ë", "–µ")
    if t in CANON_SIGNS:
        return t
    return SIGN_ALIASES.get(t)

def sign_keyboard() -> types.ReplyKeyboardMarkup:
    kb = types.ReplyKeyboardMarkup(resize_keyboard=True)
    # 4 —Å—Ç—Ä–æ–∫–∏ –ø–æ 3 –∑–Ω–∞–∫–∞ ‚Äî –∫–æ–º–ø–∞–∫—Ç–Ω–æ
    rows = [
        ["–æ–≤–µ–Ω", "—Ç–µ–ª–µ—Ü", "–±–ª–∏–∑–Ω–µ—Ü—ã"],
        ["—Ä–∞–∫", "–ª–µ–≤", "–¥–µ–≤–∞"],
        ["–≤–µ—Å—ã", "—Å–∫–æ—Ä–ø–∏–æ–Ω", "—Å—Ç—Ä–µ–ª–µ—Ü"],
        ["–∫–æ–∑–µ—Ä–æ–≥", "–≤–æ–¥–æ–ª–µ–π", "—Ä—ã–±—ã"]
    ]
    for r in rows:
        kb.row(*r)
    kb.row("/signs", "/me")
    return kb
# –ò—Å–ø–æ–ª—å–∑—É–µ–º ReplyKeyboard –¥–ª—è –±—ã—Å—Ç—Ä–æ–≥–æ –≤—ã–±–æ—Ä–∞ (–ø–∞—Ç—Ç–µ—Ä–Ω –∏–∑ –∑–∞–Ω—è—Ç–∏–π –ø–æ –∫–Ω–æ–ø–∫–∞–º) [oai_citation:7‚Ä°L2_–¢–µ–∫—Å—Ç –∫ –ª–µ–∫—Ü–∏–∏.pdf](file-service://file-6kQEVmhZuKhD1nBDo1XNnq)


# ---------- –≥–µ–Ω–µ—Ä–∞—Ü–∏—è ¬´–≥–æ—Ä–æ—Å–∫–æ–ø–∞¬ª –±–µ–∑ API (–¥–µ—Ç–µ—Ä–º–∏–Ω–∏—Ä–æ–≤–∞–Ω–Ω–æ –Ω–∞ (sign, date)) ----------
INTRO = [
    "–°–µ–≥–æ–¥–Ω—è –≤–∞—Å –∂–¥—ë—Ç", "–î–µ–Ω—å —Å—É–ª–∏—Ç", "–£—Ç—Ä–æ –ø—Ä–∏–Ω–µ—Å—ë—Ç", "–í –ø–µ—Ä–≤–æ–π –ø–æ–ª–æ–≤–∏–Ω–µ –¥–Ω—è –≤–µ—Ä–æ—è—Ç–Ω–æ",
    "–•–æ—Ä–æ—à–µ–µ –≤—Ä–µ–º—è –¥–ª—è", "–ü–æ–¥—Ö–æ–¥—è—â–∏–π –º–æ–º–µ–Ω—Ç –¥–ª—è"
]
FOCUS = ["—Ä–∞–±–æ—Ç—ã", "–ª–∏—á–Ω—ã—Ö –¥–µ–ª", "–æ–±—â–µ–Ω–∏—è", "–æ–±—É—á–µ–Ω–∏—è", "—Ç–≤–æ—Ä—á–µ—Å—Ç–≤–∞", "–º–∞–ª–µ–Ω—å–∫–∏—Ö –ø–æ–µ–∑–¥–æ–∫"]
ADVICE = [
    "–¥–µ–π—Å—Ç–≤—É–π—Ç–µ —Å–ø–æ–∫–æ–π–Ω–æ –∏ –±–µ–∑ —Å–ø–µ—à–∫–∏", "–æ–±—Ä–∞—Ç–∏—Ç–µ –≤–Ω–∏–º–∞–Ω–∏–µ –Ω–∞ –¥–µ—Ç–∞–ª–∏", "–¥–µ—Ä–∂–∏—Ç–µ –∫—É—Ä—Å –∏ –Ω–µ –æ—Ç–≤–ª–µ–∫–∞–π—Ç–µ—Å—å",
    "–Ω–µ —Å–ø–æ—Ä—å—Ç–µ –∏–∑ –ø—Ä–∏–Ω—Ü–∏–ø–∞", "–ø–æ–¥—É–º–∞–π—Ç–µ –æ –ø–æ–ª—å–∑–µ –ø—Ä–∏–≤—ã—á–µ–∫", "–Ω–µ –±–æ–π—Ç–µ—Å—å –ø–æ–ø—Ä–æ—Å–∏—Ç—å –ø–æ–º–æ—â–∏"
]
LUCK = [
    "—É–¥–∞—á–∞ –Ω–∞ –≤–∞—à–µ–π —Å—Ç–æ—Ä–æ–Ω–µ", "–æ–∫—Ä—É–∂–∞—é—â–∏–µ –Ω–∞—Å—Ç—Ä–æ–µ–Ω—ã –¥—Ä—É–∂–µ–ª—é–±–Ω–æ", "—Å–ª—É—á–∞–π –ø–æ–º–æ–∂–µ—Ç —Ç–µ–º, –∫—Ç–æ –≥–æ—Ç–æ–≤",
    "–Ω–µ–±–æ–ª—å—à–æ–π —Ä–∏—Å–∫ —Å–µ–±—è –æ–ø—Ä–∞–≤–¥–∞–µ—Ç", "–ø–æ–¥–¥–µ—Ä–∂–∫–∞ –ø—Ä–∏–¥—ë—Ç –≤–æ–≤—Ä–µ–º—è", "–¥–µ–Ω—å –ø–æ–¥–æ–π–¥—ë—Ç –¥–ª—è –Ω–æ–≤—ã—Ö –Ω–∞—á–∞–ª"
]
COLOR = ["—Å–∏–Ω–∏–π", "–∑–µ–ª—ë–Ω—ã–π", "–∂—ë–ª—Ç—ã–π", "–∫—Ä–∞—Å–Ω—ã–π", "—Ñ–∏–æ–ª–µ—Ç–æ–≤—ã–π", "–±–µ–ª—ã–π", "–æ—Ä–∞–Ω–∂–µ–≤—ã–π"]
NUMBER = [3, 4, 5, 6, 7, 8, 9]

def _pick(seq: list, seed: bytes, salt: str) -> str:
    h = hashlib.md5(seed + salt.encode("utf-8")).hexdigest()
    idx = int(h, 16) % len(seq)
    return str(seq[idx])

def make_daily_text(sign: str, for_date: date) -> str:
    """
    –ì–µ–Ω–µ—Ä–∏—Ä—É–µ—Ç 3‚Äì4 –∫–æ—Ä–æ—Ç–∫–∏—Ö —Ñ—Ä–∞–∑—ã –∏ –ø–∞—Ä—É ¬´—Ñ–∏—à–µ–∫¬ª (—Ü–≤–µ—Ç, —á–∏—Å–ª–æ).
    –î–µ—Ç–µ—Ä–º–∏–Ω–∏—Ä–æ–≤–∞–Ω–Ω–æ –¥–ª—è (sign, date) ‚Äî –±–µ–∑ –≤–Ω–µ—à–Ω–∏—Ö API.
    """
    iso = for_date.isoformat().encode("utf-8")
    sgn = sign.encode("utf-8")
    intro = _pick(INTRO, sgn+iso, ":intro")
    focus = _pick(FOCUS, sgn+iso, ":focus")
    advice = _pick(ADVICE, sgn+iso, ":advice")
    luck = _pick(LUCK, sgn+iso, ":luck")
    color = _pick(COLOR, sgn+iso, ":color")
    number = _pick(NUMBER, sgn+iso, ":num")

    emoji = SIGN_EMOJI.get(sign, "")
    return (
        f"{emoji} *{sign.capitalize()}* ‚Äî {for_date.strftime('%Y-%m-%d')}\n"
        f"{intro} –∞–∫—Ü–µ–Ω—Ç –Ω–∞ *{focus}*; {luck}. –°–æ–≤–µ—Ç—ã: {advice}.\n\n"
        f"–°—á–∞—Å—Ç–ª–∏–≤—ã–π —Ü–≤–µ—Ç: *{color}*, —á–∏—Å–ª–æ –¥–Ω—è: *{number}*.\n"
        f"_–†–∞–∑–≤–ª–µ–∫–∞—Ç–µ–ª—å–Ω—ã–π –∫–æ–Ω—Ç–µ–Ω—Ç._"
    )


# ---------- –≤—Å–ø–æ–º–æ–≥–∞—Ç–µ–ª—å–Ω—ã–µ —É—Ç–∏–ª–∏—Ç—ã ----------
def user_mention(m: types.Message) -> str:
    u = m.from_user
    return f"{u.first_name or ''}".strip() or "–¥—Ä—É–≥"

def parse_hour(token: str) -> int | None:
    try:
        h = int(token)
        return h if 0 <= h <= 23 else None
    except Exception:
        return None


# ---------- –∫–æ–º–∞–Ω–¥—ã ----------
@bot.message_handler(commands=["start", "help"])
def cmd_start(message: types.Message) -> None:
    db.ensure_user(message.from_user.id)
    text = (
        "–ü—Ä–∏–≤–µ—Ç! –Ø –ø—Ä–∏—à–ª—é *–≥–æ—Ä–æ—Å–∫–æ–ø –¥–Ω—è* –±–µ–∑ –≤—Å—è–∫–∏—Ö API ‚Äî –¥–ª—è –Ω–∞—Å—Ç—Ä–æ–µ–Ω–∏—è.\n\n"
        "–°–Ω–∞—á–∞–ª–∞ –≤—ã–±–µ—Ä–∏ –∑–Ω–∞–∫ –∏ —á–∞—Å –æ—Ç–ø—Ä–∞–≤–∫–∏:\n"
        "‚Ä¢ /set_sign <–∑–Ω–∞–∫>  –∏–ª–∏ –Ω–∞–∂–º–∏ –∫–Ω–æ–ø–∫—É —Å–æ –∑–Ω–∞–∫–æ–º\n"
        "‚Ä¢ /set_time <0..23> —á–∞—Å (–ø–æ –≤—Ä–µ–º–µ–Ω–∏ —Å–µ—Ä–≤–µ—Ä–∞)\n\n"
        "–ü–æ–ª–µ–∑–Ω–æ–µ:\n"
        "‚Ä¢ /today ‚Äî –ø—Ä–∏—Å–ª–∞—Ç—å –Ω–∞ —Å–µ–≥–æ–¥–Ω—è\n"
        "‚Ä¢ /subscribe –∏ /unsubscribe\n"
        "‚Ä¢ /me ‚Äî –ø–æ–∫–∞–∑–∞—Ç—å –º–æ–∏ –Ω–∞—Å—Ç—Ä–æ–π–∫–∏\n"
        "‚Ä¢ /signs ‚Äî —Å–ø–∏—Å–æ–∫ –∑–Ω–∞–∫–æ–≤\n"
    )
    bot.send_message(message.chat.id, text, reply_markup=sign_keyboard(), parse_mode="Markdown")


@bot.message_handler(commands=["signs"])
def cmd_signs(message: types.Message) -> None:
    lines = [f"{SIGN_EMOJI[s]} {s.capitalize()}" for s in CANON_SIGNS]
    bot.reply_to(message, "–î–æ—Å—Ç—É–ø–Ω—ã–µ –∑–Ω–∞–∫–∏:\n" + "\n".join(lines))


@bot.message_handler(commands=["set_sign"])
def cmd_set_sign(message: types.Message) -> None:
    parts = message.text.split(maxsplit=1)
    if len(parts) < 2:
        bot.reply_to(message, "–§–æ—Ä–º–∞—Ç: /set_sign <–∑–Ω–∞–∫>  (–Ω–∞–ø—Ä–∏–º–µ—Ä: /set_sign –ª–µ–≤)")
        return
    s = normalize_sign(parts[1])
    if not s:
        bot.reply_to(message, "–ù–µ —É–∑–Ω–∞–ª –∑–Ω–∞–∫. –ù–∞–ø–∏—à–∏ –æ–¥–∏–Ω –∏–∑: " + ", ".join(CANON_SIGNS))
        return
    db.ensure_user(message.from_user.id)
    db.set_sign(message.from_user.id, s)
    bot.reply_to(message, f"–ó–Ω–∞–∫ —Å–æ—Ö—Ä–∞–Ω—ë–Ω: {SIGN_EMOJI[s]} {s.capitalize()}")


@bot.message_handler(commands=["set_time"])
def cmd_set_time(message: types.Message) -> None:
    parts = message.text.split(maxsplit=1)
    hour = parse_hour(parts[1]) if len(parts) == 2 else None
    if hour is None:
        bot.reply_to(message, "–§–æ—Ä–º–∞—Ç: /set_time <—á–∞—Å 0..23>  (–Ω–∞–ø—Ä–∏–º–µ—Ä: /set_time 9)")
        return
    db.ensure_user(message.from_user.id)
    db.set_notify_hour(message.from_user.id, hour)
    bot.reply_to(message, f"–ß–∞—Å –æ—Ç–ø—Ä–∞–≤–∫–∏ —Å–æ—Ö—Ä–∞–Ω—ë–Ω: {hour}:00")


@bot.message_handler(commands=["subscribe"])
def cmd_subscribe(message: types.Message) -> None:
    db.ensure_user(message.from_user.id)
    db.set_subscribed(message.from_user.id, True)
    bot.reply_to(message, "–ü–æ–¥–ø–∏—Å–∫–∞ –≤–∫–ª—é—á–µ–Ω–∞. –Ø –ø—Ä–∏—à–ª—é —Å–æ–æ–±—â–µ–Ω–∏–µ –≤ –∑–∞–¥–∞–Ω–Ω—ã–π —á–∞—Å.")


@bot.message_handler(commands=["unsubscribe"])
def cmd_unsubscribe(message: types.Message) -> None:
    db.ensure_user(message.from_user.id)
    db.set_subscribed(message.from_user.id, False)
    bot.reply_to(message, "–ü–æ–¥–ø–∏—Å–∫–∞ –≤—ã–∫–ª—é—á–µ–Ω–∞.")


@bot.message_handler(commands=["me"])
def cmd_me(message: types.Message) -> None:
    row = db.get_user(message.from_user.id)
    if not row:
        bot.reply_to(message, "–ï—â—ë –Ω–µ –Ω–∞—Å—Ç—Ä–æ–µ–Ω–æ. –ò—Å–ø–æ–ª—å–∑—É–π /set_sign –∏ /set_time.")
        return
    sign = row["sign"] or "–Ω–µ –∑–∞–¥–∞–Ω"
    hour = row["notify_hour"]
    sub = "–≤–∫–ª—é—á–µ–Ω–∞" if row["subscribed"] else "–≤—ã–∫–ª—é—á–µ–Ω–∞"
    bot.reply_to(
        message,
        f"–ú–æ–∏ –Ω–∞—Å—Ç—Ä–æ–π–∫–∏:\n–ó–Ω–∞–∫: {sign}\n–ß–∞—Å: {hour}:00\n–ü–æ–¥–ø–∏—Å–∫–∞: {sub}"
    )


@bot.message_handler(commands=["today"])
def cmd_today(message: types.Message) -> None:
    db.ensure_user(message.from_user.id)
    row = db.get_user(message.from_user.id)
    if not row or not row["sign"]:
        bot.reply_to(message, "–°–Ω–∞—á–∞–ª–∞ /set_sign <–∑–Ω–∞–∫>.")
        return
    txt = make_daily_text(row["sign"], date.today())
    bot.send_message(message.chat.id, txt, parse_mode="Markdown")


# ---------- –æ–±—Ä–∞–±–æ—Ç–∫–∞ –Ω–∞–∂–∞—Ç–∏–π –ø–æ –∫–ª–∞–≤–∏–∞—Ç—É—Ä–µ —Å–æ –∑–Ω–∞–∫–∞–º–∏ ----------
@bot.message_handler(func=lambda m: (m.text or "").strip().lower() in CANON_SIGNS)
def kb_pick_sign(message: types.Message) -> None:
    s = (message.text or "").strip().lower()
    db.ensure_user(message.from_user.id)
    db.set_sign(message.from_user.id, s)
    bot.reply_to(message, f"–ó–Ω–∞–∫ —Å–æ—Ö—Ä–∞–Ω—ë–Ω: {SIGN_EMOJI[s]} {s.capitalize()}")


# ---------- –ø–ª–∞–Ω–∏—Ä–æ–≤—â–∏–∫ –µ–∂–µ–¥–Ω–µ–≤–Ω–æ–π –æ—Ç–ø—Ä–∞–≤–∫–∏ ----------
def scheduler_loop() -> None:
    log.info("Scheduler started")
    while True:
        now = datetime.now()               # –≤—Ä–µ–º—è —Å–µ—Ä–≤–µ—Ä–∞
        today_str = now.strftime("%Y-%m-%d")
        hour = now.hour
        try:
            due = db.list_due_users(today_str, hour)
            for u in due:
                # –°–≥–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞—Ç—å —Ç–µ–∫—Å—Ç –∏ –æ—Ç–ø—Ä–∞–≤–∏—Ç—å:
                txt = make_daily_text(u["sign"], now.date())
                try:
                    bot.send_message(u["user_id"], txt, parse_mode="Markdown")
                except Exception as e:
                    log.warning("Send failed to %s: %r", u["user_id"], e)
                # –û—Ç–º–µ—Ç–∏—Ç—å –æ—Ç–ø—Ä–∞–≤–∫—É –∑–∞ —Å–µ–≥–æ–¥–Ω—è:
                db.mark_sent_today(u["user_id"], today_str)
        except Exception as e:
            log.exception("Scheduler error: %r", e)
        time.sleep(60)  # –ø—Ä–æ–≤–µ—Ä—è–µ–º —Ä–∞–∑ –≤ –º–∏–Ω—É—Ç—É


def start_scheduler() -> None:
    t = threading.Thread(target=scheduler_loop, name="daily-scheduler", daemon=True)
    t.start()


# ---------- –º–µ–Ω—é –∫–æ–º–∞–Ω–¥ –≤ –∫–ª–∏–µ–Ω—Ç–µ (—Å–º. –õ2) ----------
def setup_bot_commands() -> None:
    cmds = [
        types.BotCommand("start", "–ù–∞—á–∞–ª–æ –∏ –ø–æ–º–æ—â—å"),
        types.BotCommand("set_sign", "–£—Å—Ç–∞–Ω–æ–≤–∏—Ç—å –∑–Ω–∞–∫ –∑–æ–¥–∏–∞–∫–∞"),
        types.BotCommand("set_time", "–£—Å—Ç–∞–Ω–æ–≤–∏—Ç—å —á–∞—Å –æ—Ç–ø—Ä–∞–≤–∫–∏"),
        types.BotCommand("today", "–ü—Ä–∏—Å–ª–∞—Ç—å –Ω–∞ —Å–µ–≥–æ–¥–Ω—è"),
        types.BotCommand("subscribe", "–í–∫–ª—é—á–∏—Ç—å –ø–æ–¥–ø–∏—Å–∫—É"),
        types.BotCommand("unsubscribe", "–í—ã–∫–ª—é—á–∏—Ç—å –ø–æ–¥–ø–∏—Å–∫—É"),
        types.BotCommand("me", "–ú–æ–∏ –Ω–∞—Å—Ç—Ä–æ–π–∫–∏"),
        types.BotCommand("signs", "–°–ø–∏—Å–æ–∫ –∑–Ω–∞–∫–æ–≤"),
    ]
    bot.set_my_commands(cmds)


# ---------- —Ç–æ—á–∫–∞ –≤—Ö–æ–¥–∞ ----------
if __name__ == "__main__":
    setup_bot_commands()        # —É–¥–æ–±—Å—Ç–≤–æ –¥–ª—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π [oai_citation:8‚Ä°L2_–¢–µ–∫—Å—Ç –∫ –ª–µ–∫—Ü–∏–∏.pdf](file-service://file-6kQEVmhZuKhD1nBDo1XNnq)
    start_scheduler()           # –∑–∞–ø—É—Å–∫–∞–µ–º —Ñ–æ–Ω–æ–≤—É—é –ø—Ä–æ–≤–µ—Ä–∫—É
    bot.infinity_polling(skip_pending=True)  # –∑–∞–ø—É—Å–∫ long polling (–ø–∞—Ç—Ç–µ—Ä–Ω –õ2/–õ3) [oai_citation:9‚Ä°L2_–¢–µ–∫—Å—Ç –∫ –ª–µ–∫—Ü–∏–∏.pdf](file-service://file-6kQEVmhZuKhD1nBDo1XNnq) [oai_citation:10‚Ä°L3.pdf](file-service://file-TzQZFVK22mksuAGPBby5ME)


